=head1 NAME

Catalyst::Manual::Tutorial::Authentication - Catalyst Tutorial - Part 5: Authentication


=head1 OVERVIEW

This is B<Part 5 of 10> for the Catalyst tutorial.

L<Tutorial Overview|Catalyst::Manual::Tutorial>

=over 4

=item 1

L<Introduction|Catalyst::Manual::Tutorial::Intro>

=item 2

L<Catalyst Basics|Catalyst::Manual::Tutorial::CatalystBasics>

=item 3

L<More Catalyst Basics|Catalyst::Manual::Tutorial::MoreCatalystBasics>

=item 4

L<Basic CRUD|Catalyst::Manual::Tutorial::BasicCRUD>

=item 5

B<Authentication>

=item 6

L<Authorization|Catalyst::Manual::Tutorial::Authorization>

=item 7

L<Debugging|Catalyst::Manual::Tutorial::Debugging>

=item 8

L<Testing|Catalyst::Manual::Tutorial::Testing>

=item 9

L<Advanced CRUD|Catalyst::Manual::Tutorial::AdvancedCRUD>

=item 10

L<Appendices|Catalyst::Manual::Tutorial::Appendices>

=back


=head1 DESCRIPTION

Now that we finally have a simple yet functional application, we can
focus on providing authentication (with authorization coming next in
Part 6).

This part of the tutorial is divided into two main sections: 1) basic,
cleartext authentication and 2) hash-based authentication.

You can checkout the source code for this example from the catalyst
subversion repository as per the instructions in
L<Catalyst::Manual::Tutorial::Intro|Catalyst::Manual::Tutorial::Intro>.

=head1 BASIC AUTHENTICATION

This section explores how to add authentication logic to a Catalyst
application.


=head2 Add Users and Roles to the Database

First, we add both user and role information to the database (we will
add the role information here although it will not be used until the
authorization section, Part 6).  Create a new SQL script file by opening
C<myapp02.sql> in your editor and insert:

    --
    -- Add users and roles tables, along with a many-to-many join table
    --
    CREATE TABLE users (
            id            INTEGER PRIMARY KEY,
            username      TEXT,
            password      TEXT,
            email_address TEXT,
            first_name    TEXT,
            last_name     TEXT,
            active        INTEGER
    );
    CREATE TABLE roles (
            id   INTEGER PRIMARY KEY,
            role TEXT
    );
    CREATE TABLE user_roles (
            user_id INTEGER,
            role_id INTEGER,
            PRIMARY KEY (user_id, role_id)
    );
    --
    -- Load up some initial test data
    --
    INSERT INTO users VALUES (1, 'test01', 'mypass', 't01@na.com', 'Joe',  'Blow', 1);
    INSERT INTO users VALUES (2, 'test02', 'mypass', 't02@na.com', 'Jane', 'Doe',  1);
    INSERT INTO users VALUES (3, 'test03', 'mypass', 't03@na.com', 'No',   'Go',   0);
    INSERT INTO roles VALUES (1, 'user');
    INSERT INTO roles VALUES (2, 'admin');
    INSERT INTO user_roles VALUES (1, 1);
    INSERT INTO user_roles VALUES (1, 2);
    INSERT INTO user_roles VALUES (2, 1);
    INSERT INTO user_roles VALUES (3, 1);

Then load this into the C<myapp.db> database with the following command:

    $ sqlite3 myapp.db < myapp02.sql


=head2 Add User and Role Information to DBIC Schema

Although we could manually edit the DBIC schema information to include
the new tables added in the previous step, let's use the C<create=static>
option on the DBIC model helper to do most of the work for us:

    $ script/myapp_create.pl model DB DBIC::Schema MyApp::Schema create=static dbi:SQLite:myapp.db
     exists "/root/dev/MyApp/script/../lib/MyApp/Model"
     exists "/root/dev/MyApp/script/../t"
    Dumping manual schema for MyApp::Schema to directory /root/dev/MyApp/script/../lib ...
    Schema dump completed.
     exists "/root/dev/MyApp/script/../lib/MyApp/Model/DB.pm"
    $
    $ ls lib/MyApp/Schema
    Authors.pm  BookAuthors.pm  Books.pm  Roles.pm  UserRoles.pm  Users.pm

Notice how the helper has added three new table-specific result source
files to the C<lib/MyApp/Schema/MyApp> directory.  And, more
importantly, even if there were changes to the existing result source
files, those changes would have only been written above the C<# DO NOT
MODIFY THIS OR ANYTHING ABOVE!> comment and your hand-edited
enhancements would have been preserved.

Speaking of "hand-edit ted enhancements," we should now add
relationship information to the three new result source files.  Edit
each of these files and add the following information between the C<#
DO NOT MODIFY THIS OR ANYTHING ABOVE!> comment and the closing C<1;>:

C<lib/MyApp/Schema/Users.pm>:

    #
    # Set relationships:
    #
    
    # has_many():
    #   args:
    #     1) Name of relationship, DBIC will create accessor with this name
    #     2) Name of the model class referenced by this relationship
    #     3) Column name in *foreign* table
    __PACKAGE__->has_many(map_user_role => 'MyApp::Schema::UserRoles', 'user_id');
    
    # many_to_many():
    #   args:
    #     1) Name of relationship, DBIC will create accessor with this name
    #     2) Name of has_many() relationship this many_to_many() is shortcut for
    #     3) Name of belongs_to() relationship in model class of has_many() above
    #   You must already have the has_many() defined to use a many_to_many().
    __PACKAGE__->many_to_many(roles => 'map_user_role', 'role');


C<lib/MyApp/Schema/Roles.pm>:

    #
    # Set relationships:
    #
    
    # has_many():
    #   args:
    #     1) Name of relationship, DBIC will create accessor with this name
    #     2) Name of the model class referenced by this relationship
    #     3) Column name in *foreign* table
    __PACKAGE__->has_many(map_user_role => 'MyApp::Schema::UserRoles', 'role_id');


C<lib/MyApp/Schema/UserRoles.pm>:

    #
    # Set relationships:
    #
    
    # belongs_to():
    #   args:
    #     1) Name of relationship, DBIC will create accessor with this name
    #     2) Name of the model class referenced by this relationship
    #     3) Column name in *this* table
    __PACKAGE__->belongs_to(user => 'MyApp::Schema::Users', 'user_id');
    
    # belongs_to():
    #   args:
    #     1) Name of relationship, DBIC will create accessor with this name
    #     2) Name of the model class referenced by this relationship
    #     3) Column name in *this* table
    __PACKAGE__->belongs_to(role => 'MyApp::Schema::Roles', 'role_id');


The code for these three sets of updates is obviously very similar to
the edits we made to the C<Books>, C<Authors>, and C<BookAuthors>
classes created in Part 3.

Note that we do not need to make any change to the
C<lib/MyApp/Schema.pm> schema file.  It simply tells DBIC to
load all of the result class files it finds in below the
C<lib/MyApp/Schema> directory, so it will automatically pick
up our new table information.


=head2 Sanity-Check Reload of Development Server

We aren't ready to try out the authentication just yet; we only want
to do a quick check to be sure our model loads correctly.  Press
C<Ctrl-C> to kill the previous server instance (if it's still running)
and restart it:

    $ script/myapp_server.pl

Look for the three new model objects in the startup debug output:

    ...
     .-------------------------------------------------------------------+----------.
    | Class                                                             | Type     |
    +-------------------------------------------------------------------+----------+
    | MyApp::Controller::Books                                          | instance |
    | MyApp::Controller::Root                                           | instance |
    | MyApp::Model::DB                                                  | instance |
    | MyApp::Model::DB::Author                                          | class    |
    | MyApp::Model::DB::Books                                           | class    |
    | MyApp::Model::DB::BookAuthors                                     | class    |
    | MyApp::Model::DB::Roles                                           | class    |
    | MyApp::Model::DB::Users                                           | class    |
    | MyApp::Model::DB::UserRoles                                       | class    |
    | MyApp::View::TT                                                   | instance |
    '-------------------------------------------------------------------+----------'
    ...

Again, notice that your "result class" classes have been "re-loaded"
by Catalyst under C<MyApp::Model>.


=head2 Include Authentication and Session Plugins

Edit C<lib/MyApp.pm> and update it as follows (everything below
C<StackTrace> is new):

    __PACKAGE__->setup(qw/
            -Debug
            ConfigLoader
            Static::Simple
    
            StackTrace
    
            Authentication
    
            Session
            Session::Store::FastMmap
            Session::State::Cookie
        /);

B<Note:> As discussed in MoreCatalystBasics, different versions of 
C<Catalyst::Devel> have used a variety of methods to load the plugins. 
You can put the plugins in the C<use Catalyst> statement if you prefer.

The C<Authentication> plugin supports Authentication while the
C<Session> plugins are required to maintain state across multiple HTTP
requests.

Note that the only required Authentication class is the main one. This
is a change that occurred in version 0.09999_01 of the
C<Authentication> plugin. You B<do not need> to specify a particular
Authentication::Store or Authentication::Credential plugin. Instead,
indicate the Store and Credential you want to use in your application
configuration (see below).

Note that there are several options for
L<Session::Store|Catalyst::Plugin::Session::Store>
(L<Session::Store::FastMmap|Catalyst::Plugin::Session::Store::FastMmap>
is generally a good choice if you are on Unix; try
L<Session::Store::File|Catalyst::Plugin::Session::Store::File> if you
are on Win32) -- consult
L<Session::Store|Catalyst::Plugin::Session::Store> and its subclasses
for additional information and options (for example to use a database-
backed session store).


=head2 Configure Authentication

Although C<__PACKAGE__-E<gt>config(name =E<gt> 'value');> is still
supported, newer Catalyst applications tend to place all configuration
information in C<myapp.conf> and automatically load this information
into C<MyApp-E<gt>config> using the
L<ConfigLoader|Catalyst::Plugin::ConfigLoader> plugin.

First, as noted in Part 3 of the tutorial, Catalyst has recently
switched from a default config file format of YAML to
C<Config::General> (an apache-like format).  In case you are using a
version of Catalyst earlier than v5.7014, delete the C<myapp.yml>, or
convert it to .conf format using the TIP in
L<Catalyst::Manual::MoreCatalystBasics>; then simply follow the
directions below to create a new C<myapp.conf> file.

Here, we need to load several parameters that tell
L<Catalyst::Plugin::Authentication|Catalyst::Plugin::Authentication>
where to locate information in your database.  To do this, edit the
C<myapp.conf> file and update it to match:

    # rename this file to MyApp.yml and put a : in front of "name" if
    # you want to use yaml like in old versions of Catalyst
    name MyApp
    <authentication>
        default_realm dbic
        <realms>
            <dbic>
                <credential>
                    # Note: this first definition would be the same as setting
                    # __PACKAGE__->config->{authentication}->{realms}->{dbic}
                    #     ->{credential} = 'Password' in lib/MyApp.pm
                    #
                    # Specify that we are going to do password-based auth
                    class Password
                    # This is the name of the field in the users table with the
                    # password stored in it
                    password_field password
                    # We are using an unencrypted password for now
                    password_type clear
                </credential>
                <store>
                    # Use DBIC to retrieve username, password & role information
                    class DBIx::Class
                    # This is the model object created by Catalyst::Model::DBIC
                    # from your schema (you created 'MyApp::Schema::User' but as
                    # the Catalyst startup debug messages show, it was loaded as
                    # 'MyApp::Model::DB::Users').
                    # NOTE: Omit 'MyApp::Model' here just as you would when using
                    # '$c->model("DB::Users)'
                    user_class DB::Users
                </store>
            </dbic>
        </realms>
    </authentication>

Inline comments in the code above explain how each field is being used.

Note that you can use many other config file formats with catalyst.
See L<Catalyst::Plugin::ConfigLoader|Catalyst::Plugin::ConfigLoader>
for details.


=head2 Add Login and Logout Controllers

Use the Catalyst create script to create two stub controller files:

    $ script/myapp_create.pl controller Login
    $ script/myapp_create.pl controller Logout

B<NOTE:> You could easily use a single controller here.  For example,
you could have a C<User> controller with both C<login> and C<logout>
actions.  Remember, Catalyst is designed to be very flexible, and leaves
such matters up to you, the designer and programmer.

Then open C<lib/MyApp/Controller/Login.pm>, locate the C<sub index
:Path :Args(0)> method (or C<sub index : Private> if you are using an
older version of Catalyst) that was automatically inserted by the
helpers when we created the Login controller above, and update the
definition of C<sub index> to match:

    =head2 index
    
    Login logic
    
    =cut
    
    sub index :Path :Args(0) {
        my ($self, $c) = @_;
    
        # Get the username and password from form
        my $username = $c->request->params->{username} || "";
        my $password = $c->request->params->{password} || "";
    
        # If the username and password values were found in form
        if ($username && $password) {
            # Attempt to log the user in
            if ($c->authenticate({ username => $username,
                                   password => $password  } )) {
                # If successful, then let them use the application
                $c->response->redirect($c->uri_for('/books/list'));
                return;
            } else {
                # Set an error message
                $c->stash->{error_msg} = "Bad username or password.";
            }
        }
    
        # If either of above don't work out, send to the login page
        $c->stash->{template} = 'login.tt2';
    }

This controller fetches the C<username> and C<password> values from the
login form and attempts to authenticate the user.  If successful, it
redirects the user to the book list page.  If the login fails, the user
will stay at the login page and receive an error message.  If the
C<username> and C<password> values are not present in the form, the
user will be taken to the empty login form.

Note that we could have used something like C<sub default :Path>, 
however, it is generally recommended (partly for historical reasons, 
and partly for code clarity) only to use C<default> in 
C<MyApp::Controller::Root>, and then mainly to generate the 404 not 
found page for the application.

Instead, we are using C<sub base :Path :Args(0) {...}> here to
specifically match the URL C</login>. C<Path> actions (aka, "literal
actions") create URI matches relative to the namespace of the
controller where they are defined.  Although C<Path> supports
arguments that allow relative and absolute paths to be defined, here
we use an empty C<Path> definition to match on just the name of the
controller itself.  The method name, C<index>, is arbitrary. We make
the match even more specific with the C<:Args(0)> action modifier --
this forces the match on I<only> C</login>, not
C</login/somethingelse>.

Next, update the corresponding method in
C<lib/MyApp/Controller/Logout.pm> to match:

    =head2 index
    
    Logout logic
    
    =cut
    
    sub index :Path :Args(0) {
        my ($self, $c) = @_;
    
        # Clear the user's state
        $c->logout;
    
        # Send the user to the starting point
        $c->response->redirect($c->uri_for('/'));
    }

As with the login controller, be sure to delete the
C<$c-E<gt>response-E<gt>body('Matched MyApp::Controller::Logout in Logout.');>
line of the C<sub index>.


=head2 Add a Login Form TT Template Page

Create a login form by opening C<root/src/login.tt2> and inserting:

    [% META title = 'Login' %]
    
    <!-- Login form -->
    <form method="post" action="[% c.uri_for('/login') %]">
      <table>
        <tr>
          <td>Username:</td>
          <td><input type="text" name="username" size="40" /></td>
        </tr>
        <tr>
          <td>Password:</td>
          <td><input type="password" name="password" size="40" /></td>
        </tr>
        <tr>
          <td colspan="2"><input type="submit" name="submit" value="Submit" /></td>
        </tr>
      </table>
    </form>


=head2 Add Valid User Check

We need something that provides enforcement for the authentication
mechanism -- a I<global> mechanism that prevents users who have not
passed authentication from reaching any pages except the login page.
This is generally done via an C<auto> action/method (prior to Catalyst
v5.66, this sort of thing would go in C<MyApp.pm>, but starting in
v5.66, the preferred location is C<lib/MyApp/Controller/Root.pm>).

Edit the existing C<lib/MyApp/Controller/Root.pm> class file and insert
the following method:

    =head2 auto
    
    Check if there is a user and, if not, forward to login page
    
    =cut
    
    # Note that 'auto' runs after 'begin' but before your actions and that
    # 'auto's "chain" (all from application path to most specific class are run)
    # See the 'Actions' section of 'Catalyst::Manual::Intro' for more info.
    sub auto : Private {
        my ($self, $c) = @_;
    
        # Allow unauthenticated users to reach the login page.  This
        # allows unauthenticated users to reach any action in the Login
        # controller.  To lock it down to a single action, we could use:
        #   if ($c->action eq $c->controller('Login')->action_for('index'))
        # to only allow unauthenticated access to the 'index' action we
        # added above.
        if ($c->controller eq $c->controller('Login')) {
            return 1;
        }
    
        # If a user doesn't exist, force login
        if (!$c->user_exists) {
            # Dump a log message to the development server debug output
            $c->log->debug('***Root::auto User not found, forwarding to /login');
            # Redirect the user to the login page
            $c->response->redirect($c->uri_for('/login'));
            # Return 0 to cancel 'post-auto' processing and prevent use of application
            return 0;
        }
    
        # User found, so return 1 to continue with processing after this 'auto'
        return 1;
    }


B<Note:> Catalyst provides a number of different types of actions,
such as C<Local>, C<Regex>, C<Private> and the new C<Path>.  You
should refer to L<Catalyst::Manual::Intro|Catalyst::Manual::Intro> for
a more detailed explanation, but the following bullet points provide a
quick introduction:

=over 4

=item *

The majority of application have traditionally used C<Local> actions
for items that respond to user requests and C<Private> actions for
those that do not directly respond to user input.

=item *

Newer Catalyst applications tend to use C<Path> actions and the
C<Args> attribute because of their power and flexibility.  You can
specify the path to match relative to the namespace of the current
module as an argument to C<Path>.  For example C<Path('list')> in
C<lib/MyApp/Controller/Books.pm> would match on the URL
C<http://localhost:3000/books/list> but C<Path('/list')> would
match on C<http://localhost:3000/list>.

=item *

Automatic "chaining" of actions by the dispatcher is a powerful
feature that allows multiple methods to handle a single URL.  See
L<Catalyst::DispatchType::Chained|Catalyst::DispatchType::Chained>
for more information on chained actions.

=item *

There are five types of build-in C<Private> actions: C<begin>, C<end>,
C<default>, C<index>, and C<auto>.

=item *

With C<begin>, C<end>, C<default>, C<index> private actions, only the
most specific action of each type will be called.  For example, if you
define a C<begin> action in your controller it will I<override> a
C<begin> action in your application/root controller -- I<only> the
action in your controller will be called.

=item *

Unlike the other actions where only a single method is called for each
request, I<every> auto action along the chain of namespaces will be
called.  Each C<auto> action will be called I<from the application/root
controller down through the most specific class>.

=back

By placing the authentication enforcement code inside the C<auto> method
of C<lib/MyApp/Controller/Root.pm> (or C<lib/MyApp.pm>), it will be
called for I<every> request that is received by the entire application.


=head2 Displaying Content Only to Authenticated Users

Let's say you want to provide some information on the login page that
changes depending on whether the user has authenticated yet.  To do
this, open C<root/src/login.tt2> in your editor and add the following
lines to the bottom of the file:

    <p>
    [%
       # This code illustrates how certain parts of the TT
       # template will only be shown to users who have logged in
    %]
    [% IF c.user_exists %]
        Please Note: You are already logged in as '[% c.user.username %]'.
        You can <a href="[% c.uri_for('/logout') %]">logout</a> here.
    [% ELSE %]
        You need to log in to use this application.
    [% END %]
    [%#
       Note that this whole block is a comment because the "#" appears
       immediate after the "[%" (with no spaces in between).  Although it
       can be a handy way to temporarily "comment out" a whole block of
       TT code, it's probably a little too subtle for use in "normal"
       comments.
    %]
    </p>

Although most of the code is comments, the middle few lines provide a
"you are already logged in" reminder if the user returns to the login
page after they have already authenticated.  For users who have not yet
authenticated, a "You need to log in..." message is displayed (note the
use of an IF-THEN-ELSE construct in TT).


=head2 Try Out Authentication

Press C<Ctrl-C> to kill the previous server instance (if it's still
running) and restart it:

    $ script/myapp_server.pl

B<IMPORTANT NOTE:> If you are having issues with authentication on 
Internet Explorer, be sure to check the system clocks on both your 
server and client machines.  Internet Explorer is very picky about 
timestamps for cookies.  Note that you can quickly sync an Ubuntu 
system with the following command:

    sudo ntpdate ntp.ubuntu.com

Or possibly try C<sudo ntpdate -u ntp.ubuntu.com> (to us an 
unpriviledged port) or C<sudo ntpdate pool.ntp.org> (to try a 
different server in case the Ubuntu NTP server is down).

Now trying going to L<http://localhost:3000/books/list> and you should 
be redirected to the login page, hitting Shift+Reload or Ctrl+Reload 
if necessary (the "You are already logged in" message should I<not> 
appear -- if it does, click the C<logout> button and try again). Note 
the C<***Root::auto User not found...> debug message in the 
development server output.  Enter username C<test01> and password 
C<mypass>, and you should be taken to the Book List page.

Open C<root/src/books/list.tt2> and add the following lines to the
bottom (below the closing </table> tag):

    <p>
      <a href="[% c.uri_for('/login') %]">Login</a>
      <a href="[% c.uri_for('form_create') %]">Create</a>
    </p>

Reload your browser and you should now see a "Login" and "Create" links
at the bottom of the page (as mentioned earlier, you can update template
files without reloading the development server).  Click the first link
to return to the login page.  This time you I<should> see the "You are
already logged in" message.

Finally, click the C<You can logout here> link on the C</login> page.
You should stay at the login page, but the message should change to "You
need to log in to use this application."


=head1 USING PASSWORD HASHES

In this section we increase the security of our system by converting
from cleartext passwords to SHA-1 password hashes.

B<Note:> This section is optional.  You can skip it and the rest of the
tutorial will function normally.

Note that even with the techniques shown in this section, the browser
still transmits the passwords in cleartext to your application.  We are
just avoiding the I<storage> of cleartext passwords in the database by
using a SHA-1 hash. If you are concerned about cleartext passwords
between the browser and your application, consider using SSL/TLS, made
easy with the Catalyst plugin Catalyst::Plugin:RequireSSL.


=head2 Get a SHA-1 Hash for the Password

Catalyst uses the C<Digest> module to support a variety of hashing
algorithms.  Here we will use SHA-1 (SHA = Secure Hash Algorithm).
First, we should compute the SHA-1 hash for the "mypass" password we are
using.  The following command-line Perl script provides a "quick and
dirty" way to do this:

    $ perl -MDigest::SHA -e 'print Digest::SHA::sha1_hex("mypass"), "\n"'
    e727d1464ae12436e899a726da5b2f11d8381b26
    $

B<Note:> If you are following along in Ubuntu, you will need to install
C<Digest::SHA> with the following command to run the example code above:

    sudo aptitude install libdigest-sha-perl

B<Note:> You should probably modify this code for production use to
not read the password from the command line.  By having the script
prompt for the cleartext password, it avoids having the password linger
in forms such as your C<.bash_history> files (assuming you are using
BASH as your shell).  An example of such a script can be found in
Appendix 3.


=head2 Switch to SHA-1 Password Hashes in the Database

Next, we need to change the C<password> column of our C<users> table to
store this hash value vs. the existing cleartext password.  Open
C<myapp03.sql> in your editor and enter:

    --
    -- Convert passwords to SHA-1 hashes
    --
    UPDATE users SET password = 'e727d1464ae12436e899a726da5b2f11d8381b26' WHERE id = 1;
    UPDATE users SET password = 'e727d1464ae12436e899a726da5b2f11d8381b26' WHERE id = 2;
    UPDATE users SET password = 'e727d1464ae12436e899a726da5b2f11d8381b26' WHERE id = 3;

Then use the following command to update the SQLite database:

    $ sqlite3 myapp.db < myapp03.sql

B<Note:> We are using SHA-1 hashes here, but many other hashing 
algorithms are supported.  See C<Digest> for more information.


=head2 Enable SHA-1 Hash Passwords in
C<Catalyst::Plugin::Authentication::Store::DBIC>

Edit C<myapp.conf> and update it to match (the C<password_type> and
C<password_hash_type> are new, everything else is the same):

    # rename this file to MyApp.yml and put a : in front of "name" if
    # you want to use yaml like in old versions of Catalyst
    name MyApp
    <authentication>
        default_realm dbic
        <realms>
            <dbic>
                <credential>
                    # Note this first definition would be the same as setting
                    # __PACKAGE__->config->{authentication}->{realms}->{dbic}
                    #     ->{credential} = 'Password' in lib/MyApp.pm
                    #
                    # Specify that we are going to do password-based auth
                    class Password
                    # This is the name of the field in the users table with the
                    # password stored in it
                    password_field password
                    # Switch to more secure hashed passwords
                    password_type  hashed
                    # Use the SHA-1 hashing algorithm
                    password_hash_type SHA-1
                </credential>
                <store>
                    # Use DBIC to retrieve username, password & role information
                    class DBIx::Class
                    # This is the model object created by Catalyst::Model::DBIC
                    # from your schema (you created 'MyApp::Schema::User' but as
                    # the Catalyst startup debug messages show, it was loaded as
                    # 'MyApp::Model::DB::Users').
                    # NOTE: Omit 'MyApp::Model' here just as you would when using
                    # '$c->model("DB::Users)'
                    user_class DB::Users
                </store>
            </dbic>
        </realms>
    </authentication>


=head2 Try Out the Hashed Passwords

Press C<Ctrl-C> to kill the previous server instance (if it's still
running) and restart it:

    $ script/myapp_server.pl

You should now be able to go to L<http://localhost:3000/books/list> and
login as before.  When done, click the "Logout" link on the login page
(or point your browser at L<http://localhost:3000/logout>).


=head1 USING THE SESSION FOR FLASH

As discussed in Part 3 of the tutorial, C<flash> allows you to set
variables in a way that is very similar to C<stash>, but it will
remain set across multiple requests.  Once the value is read, it
is cleared (unless reset).  Although C<flash> has nothing to do with
authentication, it does leverage the same session plugins.  Now that
those plugins are enabled, let's go back and improve the "delete
and redirect with query parameters" code seen at the end of the
L<Basic CRUD|Catalyst::Manual::Tutorial::BasicCRUD> part of the
tutorial.

First, open C<lib/MyApp/Controller/Books.pm> and modify C<sub delete>
to match the following (everything after the model search line of code
has changed):

    =head2 delete
    
    Delete a book
    
    =cut
    
    sub delete : Local {
        # $id = primary key of book to delete
        my ($self, $c, $id) = @_;
    
        # Search for the book and then delete it
        $c->model('DB::Books')->search({id => $id})->delete_all;
    
        # Use 'flash' to save information across requests until it's read
        $c->flash->{status_msg} = "Book deleted";
    
        # Redirect the user back to the list page
        $c->response->redirect($c->uri_for('/books/list'));
    }

Next, open C<root/src/wrapper.tt2> and update the TT code to pull from
flash vs. the C<status_msg> query parameter:

    ...
    <div id="content">
        [%# Status and error messages %]
        <span class="message">[% status_msg || c.flash.status_msg %]</span>
        <span class="error">[% error_msg %]</span>
        [%# This is where TT will stick all of your template's contents. -%]
        [% content %]
    </div><!-- end content -->
    ...

Although the sample above only shows the C<content> div, leave the 
rest of the file intact -- the only change we made to the C<wrapper.tt2>
was to add "C<|| c.request.params.status_msg>" to the 
C<E<lt>span class="message"E<gt>> line.


=head2 Try Out Flash

Restart the development server and point your browser to
L<http://localhost:3000/books/url_create/Test/1/4> to create an extra
several books.  Click the "Return to list" link and delete one of the
"Test" books you just added.  The C<flash> mechanism should retain our
"Book deleted" status message across the redirect.

B<NOTE:> While C<flash> will save information across multiple requests,
I<it does get cleared the first time it is read>.  In general, this is
exactly what you want -- the C<flash> message will get displayed on
the next screen where it's appropriate, but it won't "keep showing up"
after that first time (unless you reset it).  Please refer to
L<Catalyst::Plugin::Session|Catalyst::Plugin::Session> for additional
information.


=head2 Switch To Flash-To-Stash

Although the a use of flash above is certainly an improvement over the
C<status_msg> we employed in Part 4 of the tutorial, the 
C<status_msg || c.flash.status_msg> statement is a little ugly. A nice
alternative is to use the C<flash_to_stash> feature that automatically
copies the content of flash to stash.  This makes your controller
and template code work regardless of where it was directly access, a
forward, or a redirect. To enable C<flash_to_stash>, you can either
set the value in C<lib/MyApp.pm> by changing the default
C<__PACKAGE__-E<gt>config> setting to something like:

    __PACKAGE__->config(
            name => 'MyApp',
            session => {flash_to_stash => 1}
        );

B<or> add the following to C<myapp.conf>:

    <session>
        flash_to_stash   1
    </session>

The C<__PACKAGE__-E<gt>config> option is probably preferable here
since it's not something you will want to change at runtime without it
possibly breaking some of your code.

Then edit C<root/src/wrapper.tt2> and change the C<status_msg> line
to match the following:

    <span class="message">[% status_msg %]</span>

Restart the development server and go to
L<http://localhost:3000/books/list> in your browser.  Delete another
of the "Test" books you added in the previous step.  Flash should still
maintain the status message across the redirect even though you are no
longer explicitly accessing C<c.flash>.


=head1 AUTHOR

Kennedy Clark, C<hkclark@gmail.com>

Please report any errors, issues or suggestions to the author.  The
most recent version of the Catalyst Tutorial can be found at
L<http://dev.catalyst.perl.org/repos/Catalyst/Catalyst-Manual/5.70/trunk/lib/Catalyst/Manual/Tutorial/>.

Copyright 2006-2008, Kennedy Clark, under Creative Commons License
(L<http://creativecommons.org/licenses/by-sa/3.0/us/>).
